package mop;

import java.io.*;
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.util.zip.CRC32;
import com.oath.halodb.*;
import com.oath.halodb.javamop.*;

getConsistency() {

    Map<Integer, MonitorRecord> snapshotAtGetReq = new ConcurrentHashMap<Integer, MonitorRecord>();
    Map<Long, MonitorRecord> putResponseMap = new ConcurrentHashMap<Long, MonitorRecord>();
    Map<Integer, Boolean> expectedPutReqSuccess = new ConcurrentHashMap<Integer, Boolean>();
    HaloDBStorageEngine dbEngine;

    event create_thread after () returning (RWThread t):
        call(* RWThread.new(..)) {
            System.out.println("Create RWThread.");
    }

    event monitor_init after (HaloDBStorageEngine dbEngine):
        call(* HaloDBStorageEngine.open())
        && target(dbEngine) {
            this.dbEngine = dbEngine;
            try {
                HaloDBIterator iterator = dbEngine.db.newIterator();
                while (iterator.hasNext()) {
                    Record record = iterator.next();
                    long key = MopUtils.bytesToLong(record.getKey());
                    byte[] value = record.getValue();
                    byte[] seqBytes = Arrays.copyOfRange(value, 1024, value.length);
                    long seq = MopUtils.bytesToLong(seqBytes);
                    long checksum = MopUtils.computeChecksum(value);
                    MonitorRecord mr = new MonitorRecord(key, checksum, seq);
                    putResponseMap.put(new Long(key), mr);
                }
             } catch (HaloDBException e) {
                e.printStackTrace();
             }
    }


    event putReq before (byte[] key, byte[] value, int rId):
        execution(* HaloDBStorageEngine.put(byte[], byte[], int, int, int, int))
        && args(key, value, rId, ..) {
            long keyLong = MopUtils.bytesToLong(key);
            byte[] seqBytes = Arrays.copyOfRange(value, 1024, value.length);
            long seq = MopUtils.bytesToLong(seqBytes);
            long checksum = MopUtils.computeChecksum(value);
            MonitorRecord mr = new MonitorRecord(keyLong, checksum, seq);

            if(putResponseMap.containsKey(keyLong)) {
                MonitorRecord pr = putResponseMap.get(keyLong);
                if(seq <= pr.seq) {
                    expectedPutReqSuccess.put(rId, false);
                } else {
                    expectedPutReqSuccess.put(rId, true);
                }

            } else {
                expectedPutReqSuccess.put(rId, true);
            }
    }


    event putResp after (byte[] key, byte[] value, int rId) returning (DBPutResult result):
        execution(DBPutResult HaloDBStorageEngine.put(byte[], byte[], int, int, int, int))
        && args(key, value, rId, ..) {
            long keyLong = MopUtils.bytesToLong(result.key);
            byte[] seqBytes = Arrays.copyOfRange(value, 1024, value.length);
            long seq = MopUtils.bytesToLong(seqBytes);
            long checksum = MopUtils.computeChecksum(value);
            MonitorRecord mr = new MonitorRecord(keyLong, checksum, seq);

            if (result.success) {
                if(!expectedPutReqSuccess.get(rId)) {
                    System.out.println("ERROR: put is expected to fail but it actually succeed.");
                }
                putResponseMap.put(keyLong, mr);
            } else {
                // System.out.println(String.format("[putRes#%d] Failed", rId));
            }
            expectedPutReqSuccess.remove(rId);
    }


    event getReq before (byte[] key, int rId):
        execution(byte[] HaloDBStorageEngine.get(byte[], int, int, int))
        && args(key, rId, ..) {
            long keyLong = MopUtils.bytesToLong(key);
            if (putResponseMap.containsKey(keyLong)) {
                MonitorRecord pr = putResponseMap.get(keyLong);
                snapshotAtGetReq.put(rId, pr);
            }
    }


    event getResCall after (byte[] key, int rId) returning (byte[] result):
        call(byte[] HaloDBStorageEngine.get(byte[], int, int, int))
        && args(key, rId, ..) {
            long keyLong = MopUtils.bytesToLong(key);
            MonitorRecord pr = snapshotAtGetReq.get(rId);
            if (result == null) {
                if (pr != null) {
                    System.out.println("ERROR: Get is not Consistent!! Get responded KEYNOTFOUND even when a record existed.");
                }
            } else {
                 byte[] resultSeqBytes = Arrays.copyOfRange(result, 1024, result.length);
                 long resultSeq = MopUtils.bytesToLong(resultSeqBytes);
                 if (pr != null && !(pr.seq <= resultSeq)) {
                     System.out.println("ERROR: Get is not Consistent! Expected a larger sequencer.");
                 }
                 snapshotAtGetReq.remove(rId);
            }
    }

}
